<translation-unit> {<external-declaration>}*
<external-declaration> <function-definition>
<external-declaration> <declaration>
<function-definition> {<declaration-specifier>}* <declarator> {<declaration>}* <compound-statement>
<declaration-specifier> <storage-class-specifier>
<declaration-specifier> <type-specifier>
<declaration-specifier> <type-qualifier>
<storage-class-specifier> auto
<storage-class-specifier> register
<storage-class-specifier> static
<storage-class-specifier> extern
<storage-class-specifier> typedef
<type-specifier> void
<type-specifier> char
<type-specifier> short
<type-specifier> int
<type-specifier> long
<type-specifier> float
<type-specifier> double
<type-specifier> signed
<type-specifier> unsigned
<type-specifier> <struct-or-union-specifier>
<type-specifier> <enum-specifier>
<type-specifier> <typedef-name>
<struct-or-union-specifier> <struct-or-union> <identifier> { {<struct-declaration>}+ }
<struct-or-union-specifier> <struct-or-union> { {<struct-declaration>}+ }
<struct-or-union-specifier> <struct-or-union> <identifier>
<struct-or-union> struct
<struct-or-union> union
<struct-declaration> {<specifier-qualifier>}* <struct-declarator-list>
<specifier-qualifier> <type-specifier>
<specifier-qualifier> <type-qualifier>
<struct-declarator-list> <struct-declarator>
<struct-declarator-list> <struct-declarator-list> , <struct-declarator>
<struct-declarator> <declarator>
<struct-declarator> <declarator> : <constant-expression>
<struct-declarator> : <constant-expression>
<declarator> {<pointer>}? <direct-declarator>
<pointer> * {<type-qualifier>}* {<pointer>}?
<type-qualifier> const
<type-qualifier> volatile
<direct-declarator> <identifier>
<direct-declarator> ( <declarator> )
<direct-declarator> <direct-declarator> [ {<constant-expression>}? ]
<direct-declarator> <direct-declarator> ( <parameter-type-list> )
<direct-declarator> <direct-declarator> ( {<identifier>}* )
<constant-expression> <conditional-expression>
<conditional-expression> <logical-or-expression>
<conditional-expression> <logical-or-expression> ? <expression> : <conditional-expression>
<logical-or-expression> <logical-and-expression>
<logical-or-expression> <logical-or-expression> || <logical-and-expression>
<logical-and-expression> <inclusive-or-expression>
<logical-and-expression> <logical-and-expression> && <inclusive-or-expression>
<inclusive-or-expression> <exclusive-or-expression>
<inclusive-or-expression> <inclusive-or-expression> | <exclusive-or-expression>
<exclusive-or-expression> <and-expression>
<exclusive-or-expression> <exclusive-or-expression> ^ <and-expression>
<and-expression> <equality-expression>
<and-expression> <and-expression> & <equality-expression>
<equality-expression> <relational-expression>
<equality-expression> <equality-expression> == <relational-expression>
<equality-expression> <equality-expression> != <relational-expression>
<relational-expression> <shift-expression>
<relational-expression> <relational-expression> < <shift-expression>
<relational-expression> <relational-expression> > <shift-expression>
<relational-expression> <relational-expression> <= <shift-expression>
<relational-expression> <relational-expression> >= <shift-expression>
<shift-expression> <additive-expression>
<shift-expression> <shift-expression> << <additive-expression>
<shift-expression> <shift-expression> >> <additive-expression>
<additive-expression> <multiplicative-expression>
<additive-expression> <additive-expression> + <multiplicative-expression>
<additive-expression> <additive-expression> - <multiplicative-expression>
<multiplicative-expression> <cast-expression>
<multiplicative-expression> <multiplicative-expression> * <cast-expression>
<multiplicative-expression> <multiplicative-expression> / <cast-expression>
<multiplicative-expression> <multiplicative-expression> % <cast-expression>
<cast-expression> <unary-expression>
<cast-expression> ( <type-name> ) <cast-expression>
<unary-expression> <postfix-expression>
<unary-expression> ++ <unary-expression>
<unary-expression> -- <unary-expression>
<unary-expression> <unary-operator> <cast-expression>
<unary-expression> sizeof <unary-expression>
<unary-expression> sizeof <type-name>
<postfix-expression> <primary-expression>
<postfix-expression> <postfix-expression> [ <expression> ]
<postfix-expression> <postfix-expression> ( {<assignment-expression>}* )
<postfix-expression> <postfix-expression> . <identifier>
<postfix-expression> <postfix-expression> -> <identifier>
<postfix-expression> <postfix-expression> ++
<postfix-expression> <postfix-expression> --
<primary-expression> <identifier>
<primary-expression> <constant>
<primary-expression> <string>
<primary-expression> ( <expression> )
<constant> <integer-constant>
<constant> <character-constant>
<constant> <floating-constant>
<constant> <enumeration-constant>
<expression> <assignment-expression>
<expression> <expression> , <assignment-expression>
<assignment-expression> <conditional-expression>
<assignment-expression> <unary-expression> <assignment-operator> <assignment-expression>
<assignment-operator> =
<assignment-operator> *=
<assignment-operator> /=
<assignment-operator> %=
<assignment-operator> +=
<assignment-operator> -=
<assignment-operator> <<=
<assignment-operator> >>=
<assignment-operator> &=
<assignment-operator> ^=
<assignment-operator> |=
<unary-operator> &
<unary-operator> *
<unary-operator> +
<unary-operator> -
<unary-operator> ~
<unary-operator> !
<type-name> {<specifier-qualifier>}+ {<abstract-declarator>}?
<parameter-type-list> <parameter-list>
<parameter-type-list> <parameter-list> , ...
<parameter-list> <parameter-declaration>
<parameter-list> <parameter-list> , <parameter-declaration>
<parameter-declaration> {<declaration-specifier>}+ <declarator>
<parameter-declaration> {<declaration-specifier>}+ <abstract-declarator>
<parameter-declaration> {<declaration-specifier>}+
<abstract-declarator> <pointer>
<abstract-declarator> <pointer> <direct-abstract-declarator>
<abstract-declarator> <direct-abstract-declarator>
<direct-abstract-declarator> ( <abstract-declarator> )
<direct-abstract-declarator> {<direct-abstract-declarator>}? [ {<constant-expression>}? ]
<direct-abstract-declarator> {<direct-abstract-declarator>}? ( {<parameter-type-list>}? )
<enum-specifier> enum <identifier> { <enumerator-list> }
<enum-specifier> enum { <enumerator-list> }
<enum-specifier> enum <identifier>
<enumerator-list> <enumerator>
<enumerator-list> <enumerator-list> , <enumerator>
<enumerator> <identifier>
<enumerator> <identifier> = <constant-expression>
<typedef-name> <identifier>
<declaration> {<declaration-specifier>}+ {<init-declarator>}* ;
<init-declarator> <declarator>
<init-declarator> <declarator> = <initializer>
<initializer> <assignment-expression>
<initializer> { <initializer-list> }
<initializer> { <initializer-list> , }
<initializer-list> <initializer>
<initializer-list> <initializer-list> , <initializer>
<compound-statement> { {<declaration>}* {<statement>}* }
<statement> <labeled-statement>
<statement> <expression-statement>
<statement> <compound-statement>
<statement> <selection-statement>
<statement> <iteration-statement>
<statement> <jump-statement>
<labeled-statement> <identifier> : <statement>
<labeled-statement> case <constant-expression> : <statement>
<labeled-statement> default : <statement>
<expression-statement> {<expression>}? ;
<selection-statement> if ( <expression> ) <statement>
<selection-statement> if ( <expression> ) <statement> else <statement>
<selection-statement> switch ( <expression> ) <statement>
<iteration-statement> while ( <expression> ) <statement>
<iteration-statement> do <statement> while ( <expression> ) ;
<iteration-statement> for ( {<expression>}? ; {<expression>}? ; {<expression>}? ) <statement>
<jump-statement> goto <identifier> ;
<jump-statement> continue ;
<jump-statement> break ;
<jump-statement> return {<expression>}? ;
